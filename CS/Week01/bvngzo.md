# 자료구조 - 1

## 1. 배열

**질문:**
1. 배열의 깊은 복사와 얕은 복사를 설명해주세요?
    - 1-1. 자바에서 깊은 복사를 지원하는 함수는 무엇이 있나요?
  
    - 1-2. Clone 함수는 모든 경우에서 깊은 복사를 지원하나요?
   
2. 배열 인덱스 접근의 시간복잡도는 왜 O(1)인가요?
    - 2-1. Object[] 에는 new int[3], new double[100], 사용자 정의 클래스도 동시에 입력가능한데 이 경우에도 배열 한 셀의크기는 동일한가요?
  
**예상 답변:**

A 1
  - 배열의 옅은 복사는 배열 내부 원소의 값이 아닌 배열의 참조값을 복사하는 것을 의미합니다.
    - 연산자는 "=" 연산자를 사용하고 A={1,2,3,4}일 때 B = A 연산을 할 경우 B는 A의 얕은 복사라 합니다.
    - 얕은 복사를 할 경우 배열 A의 원소값을 변경했을 때 배열 B의 원소도 동시에 바뀌니 주의해야 합니다.
  - 배열의 깊은 복사는 배열 내부 원소의 값을 다른 배열 원소로 복사하는 것 입니다.
    - 반복문을 통해 배열 A의 원소를 배열 B에 옮길 수 있습니다.
    - 배열 A의 원소값을 변경해도 배열 B의 원소값은 유지됩니다.

A 1-1
  - 자바에서 깊은 복사를 지원하는 함수는 Arrays.copyOf, System.arraycopy, Object.clone 메소드가 있습니다.

A 1-2
  - clone 함수의 경우 일차원 배열에서는 깊은 복사를 지원하지만 2차원 이상의 배열부터는 얕은 복사를 지원합니다.
    - clone 함수를 사용하여 2차원 배열을 깊은 복사하기 위해서는 각 행별로 clone함수를 사용해야합니다.

A 2
  - 배열의 경우 같은 type의 원소들의 나열이기 때문에 배열 한 셀의 크기는 모두 동일합니다.
    - int[] arr = new int[4] 일때 arr에는 0번째 원소의 주소값이 들어갑니다. 따라서 arr[3]은 arr[0] + (sizeof(int))*3으로 접근 가능하므로 시간복잡도는 O(1)입니다.
   
A 2-1
  - Object 배열에는 객체 자체가 들어가는 것이 아니라 객체의 참조값이 들어가므로 질문의 상황에서도 Object 배열 한 셀의 크기는 8byte로 동일합니다.
  

## 2. ArrayList

**질문:**
ArrayList의 add(e) 함수는 시간복잡도가 어떻게 되나요?

**예상 답변:**
- O(1)입니다.
  - ArrayList의 경우 내부 구현은 배열로 되어있고 내부 배열이 가득차게되면 resizing이 필요합니다.
  - resizing 시 내부 배열은 약 1.5배 정도 증가하고 system.arraycopy 함수가 호출되므로 이 때 시간 복잡도는 O(n)입니다.
  - 내부 배열의 크기가 충분하다면 add함수의 경우 내부 배열의 index를 통해 원소가 추가되므로 이 때 시간 복잡도는 O(1)입니다.
  - resizing은 마지막 호출 후 배열의 원소가 (1/3)*n개가 채워질 때마다 호출되므로 add 메소드는 O(n /(0.333n))이므로 O{1)입니다.

## 3. Hash

**질문:**
1. 해시 충돌을 막는 방법에는 무엇이 있나요?
    - 1-1 자바에서 해시출동을 피하기위해 어던 방법을 사용하나요? 

**예상 답변:**
A1
- 개방 주소법 
    - 충돌이 발생한 버킷의 인덱스가 아닌 다른 인덱스에 데이터를 저장합니다.
        - 선형 조사법
            - 충돌이 발생한 인덱스의 다음 인덱스부터 순차적으로 가용한 인덱스를 탐색하는 방법입니다.
                - 충돌이 발생한 인덱스 인근에 여러 데이터가 몰려 저장될 경우 속도가 저하될 수 있습니다.  
        - 이차 조사법
            - 충돌이 발생한 인덱스에서 제곱 수만큼 떨어진 거리에 위치한 인덱스를 탐색하는 방법입니다.
                - 충돌이 발생한 인덱스 인근에 데이터가 몰리는 현상을 완화합니다.
                - 위 문제에 대한 근본적인 해결책은 아닙니다.
- 이중 해싱
    - 2개의 해시 함수를 사용하는 방법입니다.
    - 충돌 발생 시 보조 해시 함수에 대한 해시 값 만큼 떨어진 거리에 위치한 인덱스를 찾는 방법입니다.
        - 충돌 발생 시 f(key) + g(key)로 인덱스를 생성합니다.
            - 또 충돌 발생시 f(key) + n*g(key) 순으로 인덱스를 탐색합니다.
         
- 폐쇄 주소법
  - 충돌 발생한 데이터를 연결 리스트로 추가합니다.
    - 하나의 테이블 인덱스에 여러 데이터가 연결 리스트의 노드로써 존재 가능합니다.
    - 구현이 단순하다는 자점이 있지만, 충돌 데이터가 많아질 수록 속도가 터하될 수 있습니다. 

A1-1
- 자바에서는 해시 충돌을 막기위해 폐쇄주소법을 사용합니다.
  - 자바 8의 경우 연결리스트 방식으로 체이닝을 구현하지만 원소가 많아지게 되면 RB 트리를 병행합니다.   
